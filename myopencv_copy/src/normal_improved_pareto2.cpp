/*
 * Advanced Robot Motion Planning with Pareto Optimization
 * ======================================================
 *
 * This program implements a multi-threaded approach to optimized robot motion planning
 * using ROS, MoveIt, and Pareto front optimization. It finds the best motion plans for
 * approaching surfaces detected by computer vision.
 *
 * Main components:
 * 1. VISION PROCESSING: Gets surface centroids and normal vectors from OpenCV service
 * 2. PARALLEL PLANNING: Spawns multiple threads to explore different approach angles
 * 3. PARETO OPTIMIZATION: Evaluates plans based on safety, path length, and smoothness
 * 4. PLAN EXECUTION: Executes the optimal motion plan on the robot
 *
 * Algorithm flow:
 * - Request surface data from OpenCV service
 * - Create thread pool and spawn multiple planning threads
 * - Each thread explores different approach angles at a selected centroid
 * - Collect and filter motion plans based on quality thresholds
 * - Apply Pareto optimization to find optimal trade-offs
 * - Normalize and weight metrics to select best plan
 * - Execute the best plan on the robot
 *
 * Key metrics for plan quality:
 * - Safety: Distance to obstacles (higher is better)
 * - Joint length: Path length in joint space (lower is better)
 * - Cartesian length: Path length in workspace (lower is better)
 * - Smoothness: Trajectory jerk estimation (lower is better)
 */

/*****************************************************************************
 * INCLUDES AND GLOBAL DEFINITIONS
 *****************************************************************************/

// ROS and MoveIt core libraries
#include <ros/ros.h>
#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>

// MoveIt messages for collision object handling
#include <moveit_msgs/AttachedCollisionObject.h>
#include <moveit_msgs/CollisionObject.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>

// Custom service for normal vector calculation from vision data
#include "opencv_services/all_normal.h" // Correct header for all_normal.srv

// TF2 libraries for 3D transformations and quaternion operations
#include <tf2/LinearMath/Quaternion.h>
#include <tf2/LinearMath/Vector3.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h> // For conversions between tf2 and geometry_msgs

// Define PI if not already available
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Standard C++ libraries
#include <algorithm> // For std::min_element and std::max_element
#include <geometry_msgs/Pose.h>
#include <trajectory_msgs/JointTrajectoryPoint.h>

// MoveIt libraries for trajectory handling and robot model
#include <moveit/robot_trajectory/robot_trajectory.h>
#include <moveit/robot_model/robot_model.h>

// MoveIt libraries for collision checking
#include <moveit/planning_scene/planning_scene.h>
#include <moveit/collision_detection/collision_tools.h>
#include <limits> // For std::numeric_limits
#include <moveit/collision_detection/collision_common.h>
#include <moveit/trajectory_processing/trajectory_tools.h>

// MoveIt libraries for robot state management
#include <moveit/robot_state/robot_state.h>
#include <moveit/robot_state/conversions.h>

// Motion planning and trajectory processing libraries
#include <moveit/trajectory_processing/iterative_time_parameterization.h>
#include <Eigen/Dense>
#include <random>

// Concurrency and threading libraries
#include <thread>
#include <mutex>
#include <unordered_map>
#include <set>

// File I/O and timing libraries
#include <fstream> // For file output
#include <string>  // For string handling
#include <chrono>  // For timing measurements

// Custom thread pool implementation
#include "ThreadPool.h" // Thread pool header
#include <future>       // For std::future

// Global mutex to protect access to the shared plans vector
std::mutex g_plan_mutex;

/**
 * PlanMetrics Structure
 *
 * Stores metrics and information about a motion plan generated by a thread.
 * Used to evaluate and compare different trajectory plans.
 */
struct PlanMetrics
{
    int thread_id;                                             // ID of the thread that generated this plan
    int plans_attempted;                                       // Total number of plans attempted by the thread
    int plans_successful;                                      // Number of successful plans generated by the thread
    moveit::planning_interface::MoveGroupInterface::Plan plan; // The actual motion plan
    double safety;                                             // Safety metric (distance to obstacles)
    double joint_length;                                       // Joint space path length
    double cartesian_length;                                   // Cartesian space path length
    double smoothness;                                         // Smoothness metric (lower is better)
    bool success;                                              // Whether the plan was successful
};

// Global mutex to protect MoveGroupInterface::plan calls which are not thread-safe
std::mutex g_move_group_mutex;

// Vector to store all successful plans from threads for later analysis
std::vector<PlanMetrics> g_all_thread_plans;

/*
 * Constants for approach angle optimization
 *
 * These define the angle ranges and offset values for different quadrants
 * when computing approach angles for the robot end effector.
 */
// Define angle bounds for four quadrants (in degrees)
constexpr double LOWER_BOUND_0_90 = 0.0;
constexpr double UPPER_BOUND_0_90 = 90.0;

constexpr double LOWER_BOUND_90_180 = 90.0;
constexpr double UPPER_BOUND_90_180 = 180.0;

constexpr double LOWER_BOUND_180_270 = 180.0;
constexpr double UPPER_BOUND_180_270 = 270.0;

constexpr double LOWER_BOUND_270_360 = 270.0;
constexpr double UPPER_BOUND_270_360 = 360.0;

// Define offset_y values for each quadrant (tool positioning offsets)
constexpr double OFFSET_Y_0_90 = 0.0275;
constexpr double OFFSET_Y_90_180 = 0.02935; // acceptable
constexpr double OFFSET_Y_180_270 = 0.0295; // acceptable
constexpr double OFFSET_Y_270_360 = 0.0275;

constexpr double OFFSET_Y_DEFAULT = 0.028; // Fallback/default value

constexpr double ANGLE_TOLERANCE = 1e-6; // Small tolerance for angle comparisons

/*****************************************************************************
 * ANGLE UTILITIES AND OPTIMIZATION
 *
 * Functions for determining optimal approach angles and checking feasibility
 *****************************************************************************/

/**
 * Check if an angle is within a specified range
 *
 * @param angle The angle to check (in degrees)
 * @param lower The lower bound of the range (in degrees)
 * @param upper The upper bound of the range (in degrees)
 * @return true if the angle is within the range (inclusive of tolerance), false otherwise
 */
bool isAngleWithinRange(double angle, double lower, double upper)
{
    return (angle > lower - ANGLE_TOLERANCE) && (angle < upper + ANGLE_TOLERANCE);
}

/**
 * Adjust the y-offset value based on the approach angle
 *
 * This function determines the appropriate y-offset for the end-effector
 * based on which quadrant the approach angle falls within. Different
 * quadrants require different offsets for optimal tool positioning.
 *
 * @param angle_deg The approach angle in degrees (0-360)
 * @return The adjusted offset_y value for the given angle
 */
double adjustOffsetY(double angle_deg)
{
    // Normalize angle to [0, 360)
    angle_deg = fmod(angle_deg, 360.0);
    if (angle_deg < 0.0)
    {
        angle_deg += 360.0;
    }

    if (isAngleWithinRange(angle_deg, LOWER_BOUND_0_90, UPPER_BOUND_0_90))
    {
        return OFFSET_Y_0_90;
    }
    else if (isAngleWithinRange(angle_deg, LOWER_BOUND_90_180, UPPER_BOUND_90_180))
    {
        return OFFSET_Y_90_180;
    }
    else if (isAngleWithinRange(angle_deg, LOWER_BOUND_180_270, UPPER_BOUND_180_270))
    {
        return OFFSET_Y_180_270;
    }
    else if (isAngleWithinRange(angle_deg, LOWER_BOUND_270_360, UPPER_BOUND_270_360))
    {
        return OFFSET_Y_270_360;
    }

    // Fallback to default if none of the ranges match (shouldn't happen)
    return OFFSET_Y_DEFAULT;
}

/**
 * Select the optimal approach angle from a range of accessible angles
 *
 * This function iterates through the provided ranges of accessible angles,
 * starting with the widest range, and tries to find a feasible angle
 * for approaching the target. It tests multiple angles within each range
 * until it finds one that allows for collision-free inverse kinematics.
 *
 * @param selected_angle_deg Output parameter for the selected angle in degrees
 * @param adjusted_offset_y Output parameter for the adjusted y-offset
 * @param accessible_ranges Vector of angle ranges (pairs of start and end angles)
 * @param robot_model Pointer to the robot model
 * @param planning_scene Pointer to the planning scene for collision checking
 * @param centroid Target position (centroid)
 * @param rotation_matrix Rotation matrix for the approach direction
 * @param approach_distance Distance from the target for the approach position
 * @return true if a feasible angle was found, false otherwise
 */
bool selectOptimalAngle(double &selected_angle_deg, double &adjusted_offset_y,
                        const std::vector<std::pair<double, double>> &accessible_ranges,
                        const moveit::core::RobotModelConstPtr &robot_model,
                        const planning_scene::PlanningScenePtr &planning_scene,
                        const geometry_msgs::Point &centroid,
                        const tf2::Matrix3x3 &rotation_matrix,
                        double approach_distance)
{
    // ALGORITHM OVERVIEW:
    // 1. Sort ranges by width (wider ranges prioritized)
    // 2. For each range, try angles in this order: center, center±step, center±2*step, etc.
    // 3. For each angle, check if IK solution exists without collisions
    // 4. Return the first feasible angle, or default values if none found

    // 1) Sort ranges by width in descending order (prioritize wider ranges)
    std::vector<std::pair<double, double>> sorted_ranges = accessible_ranges;
    std::sort(sorted_ranges.begin(), sorted_ranges.end(),
              [](const std::pair<double, double> &a, const std::pair<double, double> &b) -> bool
              {
                  return (b.second - b.first) < (a.second - a.first); // descending order
              });

    // 2) Try multiple angles within each range
    constexpr double sub_step_deg = 5.0; // Angle increment (adjustable)
    for (const auto &range : sorted_ranges)
    {
        double start = range.first;
        double end = range.second;
        double center = 0.5 * (start + end);

        // Create a list of candidate angles (center, center-step, center+step, etc.)
        std::vector<double> angle_candidates;
        angle_candidates.push_back(center);
        for (double offset = sub_step_deg; center - offset >= start || center + offset <= end; offset += sub_step_deg)
        {
            if (center - offset >= start)
            {
                angle_candidates.push_back(center - offset);
            }
            if (center + offset <= end)
            {
                angle_candidates.push_back(center + offset);
            }
        }

        // Try each candidate angle for IK and collision checking
        for (double angle_deg : angle_candidates)
        {
            double temp_adjusted_offset_y = adjustOffsetY(angle_deg);
            // Perform IK and collision checking
            bool feasible = false;

            // Call the IK and collision check function
            feasible = isFeasibleAngle(angle_deg, temp_adjusted_offset_y,
                                       robot_model, planning_scene,
                                       centroid, rotation_matrix, approach_distance);

            if (feasible)
            {
                selected_angle_deg = angle_deg;
                adjusted_offset_y = temp_adjusted_offset_y;
                ROS_INFO_STREAM("Selected feasible angle: " << selected_angle_deg << " degrees.");
                return true; // Success, return immediately
            }
        }
    }

    // If all candidate angles failed, use default values
    selected_angle_deg = 0.0;
    adjusted_offset_y = OFFSET_Y_DEFAULT;
    ROS_WARN_STREAM("All angle candidates failed. Using default angle and offset_y.");
    return false;
}

/**
 * Check if a specific approach angle is feasible
 *
 * This function performs inverse kinematics (IK) calculations and collision detection
 * to determine if the robot can reach a specific pose at the given approach angle.
 *
 * @param angle_deg The approach angle to check (in degrees)
 * @param offset_y The y-offset to use for the end-effector
 * @param robot_model Pointer to the robot model
 * @param planning_scene Pointer to the planning scene for collision checking
 * @param centroid Target position (centroid)
 * @param rotation_matrix Rotation matrix for the approach direction
 * @param approach_distance Distance from the target for the approach position
 * @return true if the angle is feasible (has valid IK solution and no collisions), false otherwise
 */
bool isFeasibleAngle(double angle_deg, double offset_y,
                     const moveit::core::RobotModelConstPtr &robot_model,
                     const planning_scene::PlanningScenePtr &planning_scene,
                     const geometry_msgs::Point &centroid,
                     const tf2::Matrix3x3 &rotation_matrix,
                     double approach_distance)
{
    // ALGORITHM OVERVIEW:
    // 1. Convert angle to rotation and compute target pose
    // 2. Check if an IK solution exists
    // 3. Check if the solution is collision-free
    // 4. Return true only if both IK and collision checks pass

    // 1. Convert angle from degrees to radians
    double angle_rad = angle_deg * M_PI / 180.0;

    // 2. Create quaternion for rotation around Z axis
    tf2::Quaternion q_rot;
    q_rot.setRPY(0, 0, angle_rad);
    q_rot.normalize();

    // 3. Calculate rotation matrix
    tf2::Matrix3x3 selected_rotation_matrix(q_rot);
    tf2::Matrix3x3 final_rotation_matrix = rotation_matrix * selected_rotation_matrix;

    // 4. Calculate final target position
    double offset_x = 0.0; // Can be adjusted if needed
    tf2::Vector3 local_target_position(offset_x, offset_y, approach_distance);
    tf2::Vector3 final_target_position = final_rotation_matrix * local_target_position +
                                         tf2::Vector3(centroid.x, centroid.y, centroid.z);

    // 5. Create target pose
    geometry_msgs::Pose target_pose;
    target_pose.position.x = final_target_position.x();
    target_pose.position.y = final_target_position.y();
    target_pose.position.z = final_target_position.z();
    target_pose.orientation = tf2::toMsg(q_rot);

    // 6. Calculate inverse kinematics
    moveit::core::RobotStatePtr kinematic_state(new moveit::core::RobotState(robot_model));
    kinematic_state->setToDefaultValues();
    bool found_ik = kinematic_state->setFromIK(robot_model->getJointModelGroup("manipulator"), target_pose);

    if (!found_ik)
    {
        ROS_WARN_STREAM("IK failed for angle: " << angle_deg << " degrees.");
        return false;
    }

    // 7. Check for collisions
    collision_detection::CollisionRequest collision_request;
    collision_detection::CollisionResult collision_result;
    collision_request.group_name = "manipulator";
    collision_request.contacts = false; // Disable distance calculation
    planning_scene->checkCollision(collision_request, collision_result, *kinematic_state);

    if (collision_result.collision)
    {
        ROS_WARN_STREAM("Collision detected for angle: " << angle_deg << " degrees.");
        return false;
    }

    // No collision
    return true;
}

/*****************************************************************************
 * UTILITY FUNCTIONS
 *
 * Helper functions for coordinate conversion and collision checking
 *****************************************************************************/

/**
 * Convert a MoveIt RobotState to a geometry_msgs::Pose
 *
 * This utility function extracts the pose (position and orientation) of a
 * specific link from a RobotState object.
 *
 * @param state The robot state to extract the pose from
 * @param ee_link The name of the end-effector link
 * @return The pose of the specified link in the robot state
 */
geometry_msgs::Pose state_to_pose(const moveit::core::RobotState &state, const std::string &ee_link)
{
    const Eigen::Isometry3d &transform = state.getGlobalLinkTransform(ee_link);
    geometry_msgs::Pose pose;
    pose.position.x = transform.translation().x();
    pose.position.y = transform.translation().y();
    pose.position.z = transform.translation().z();
    Eigen::Quaterniond q_eigen(transform.rotation());
    pose.orientation.x = q_eigen.x();
    pose.orientation.y = q_eigen.y();
    pose.orientation.z = q_eigen.z();
    pose.orientation.w = q_eigen.w();
    return pose;
}

/**
 * Check if a planned trajectory is collision-free
 *
 * This function verifies if a planned trajectory is accessible (collision-free)
 * by checking each waypoint against the planning scene.
 *
 * @param move_group The MoveGroupInterface for the robot
 * @param plan The motion plan to check
 * @param planning_scene The planning scene for collision checking
 * @return true if the trajectory is collision-free, false otherwise
 */
bool isAccessible(const moveit::planning_interface::MoveGroupInterface &move_group,
                  const moveit::planning_interface::MoveGroupInterface::Plan &plan,
                  const planning_scene::PlanningScenePtr &planning_scene)
{
    // Update the planning scene to reflect the latest state of the robot
    planning_scene->getCurrentStateNonConst().update();

    // Create a RobotTrajectory object
    moveit::core::RobotStatePtr robot_state = move_group.getCurrentState();
    robot_trajectory::RobotTrajectory rt(move_group.getRobotModel(), move_group.getName());
    rt.setRobotTrajectoryMsg(*robot_state, plan.trajectory_);

    // Check collision at each waypoint
    size_t waypoint_count = rt.getWayPointCount();

    for (size_t i = 0; i < waypoint_count; ++i)
    {
        const moveit::core::RobotState &state = rt.getWayPoint(i);

        // Compute collision
        collision_detection::CollisionRequest collision_request;
        collision_detection::CollisionResult collision_result;
        collision_request.contacts = true;     // Enable detailed contact information
        collision_request.max_contacts = 1000; // Increase max contacts to get all possible collisions

        planning_scene->checkCollision(collision_request, collision_result, state);

        if (collision_result.collision)
        {
            // Log detailed collision information
            for (const auto &contact_pair : collision_result.contacts)
            {
                const std::string &contact_body_1 = contact_pair.first.first;
                const std::string &contact_body_2 = contact_pair.first.second;
                ROS_WARN_STREAM("Collision detected between " << contact_body_1
                                                              << " and " << contact_body_2 << " at waypoint " << i);
            }
            // If in collision, inaccessible
            return false;
        }
    }

    // If no collisions detected, accessible
    return true;
}

/**
 * Call the OpenCV service to get normal vectors with robust error handling
 *
 * This function calls the all_normal service with retry logic and proper
 * error handling in case of service failure.
 *
 * @param client The service client for the all_normal service
 * @param srv The service request/response message
 * @param max_retries Maximum number of retries in case of failure
 * @return true if the service call succeeded, false otherwise
 */
bool callAllNormalService(ros::ServiceClient &client, opencv_services::all_normal &srv, int max_retries = 5)
{
    for (int i = 0; i < max_retries; ++i)
    {
        try
        {
            if (client.call(srv))
            {
                if (srv.response.success)
                {
                    ROS_INFO_STREAM("Service call successful");
                    return true;
                }
                else
                {
                    ROS_WARN_STREAM("Service responded with failure status, retrying (" << i + 1 << "/" << max_retries << ")");
                }
            }
            else
            {
                ROS_WARN_STREAM("Failed to call all_normal_service, retrying (" << i + 1 << "/" << max_retries << ")");
            }
        }
        catch (const std::exception &e)
        {
            ROS_ERROR_STREAM("Exception occurred during service call: " << e.what());
        }
        ros::Duration(1.0).sleep(); // Wait before retrying
    }
    ROS_ERROR_STREAM("Service call failed after " << max_retries << " attempts.");
    return false;
}

/******************************************************************************
 * TRAJECTORY PLANNING AND EVALUATION
 *
 * This section contains functions for generating, evaluating, and selecting
 * motion plans for the robot arm. It includes:
 * - Motion plan generation with multiple attempts
 * - Safety and collision checking
 * - Path metrics calculation (joint space, Cartesian space, smoothness)
 * - Plan evaluation and selection
 ******************************************************************************/

/**
 * Generate multiple safe motion plans and calculate their metrics
 *
 * This function attempts to create multiple motion plans for the given move_group,
 * checking their safety and calculating various metrics for each plan.
 * It switches between different planners for robustness.
 *
 * @param move_group The MoveGroupInterface for planning
 * @param successful_plans_out Output vector to store the successful plans with metrics
 * @param planning_scene The planning scene for collision checking
 * @return true if at least one successful plan was found, false otherwise
 */
bool plan_safe(moveit::planning_interface::MoveGroupInterface &move_group,
               std::vector<PlanMetrics> &successful_plans_out, // Vector to store multiple plans
               const planning_scene::PlanningScenePtr &planning_scene)
{
    const int max_retries = 5;

    // Initialize plan attempt and success counters
    int plans_attempted = 0;
    int plans_successful = 0;

    // Internal structure to hold plan metrics before conversion
    struct InternalPlanMetrics
    {
        moveit::planning_interface::MoveGroupInterface::Plan plan;
        double safety;
        double joint_length;
        double cartesian_length;
        double smoothness;
    };

    std::vector<InternalPlanMetrics> successful_plans;

    const moveit::core::RobotModelConstPtr &robot_model = move_group.getRobotModel();
    const std::string group_name = move_group.getName();

    // Lambda: check collision using cloned planning_scene
    auto isAccessible = [&](const moveit::planning_interface::MoveGroupInterface::Plan &plan) -> bool
    {
        robot_trajectory::RobotTrajectory rt(robot_model, group_name);
        rt.setRobotTrajectoryMsg(*move_group.getCurrentState(), plan.trajectory_);

        size_t waypoint_count = rt.getWayPointCount();
        for (size_t i = 0; i < waypoint_count; ++i)
        {
            const moveit::core::RobotState &state = rt.getWayPoint(i);

            collision_detection::CollisionRequest collision_request;
            collision_detection::CollisionResult collision_result;
            collision_request.contacts = false;

            // Check for collisions using the planning scene
            planning_scene->checkCollision(collision_request, collision_result, state);
            if (collision_result.collision)
            {
                return false;
            }
        }
        return true;
    };

    // Lambda: calculate metrics for a given plan
    auto calculateMetrics = [&](const moveit::planning_interface::MoveGroupInterface::Plan &plan, InternalPlanMetrics &metrics) -> void
    {
        metrics.safety = std::numeric_limits<double>::max(); // later compute min distance
        metrics.joint_length = 0.0;
        metrics.cartesian_length = 0.0;
        metrics.smoothness = 0.0;

        // Calculate joint space path length
        const auto &points = plan.trajectory_.joint_trajectory.points;
        for (size_t i = 1; i < points.size(); ++i)
        {
            double distance = 0.0;
            for (size_t j = 0; j < points[i].positions.size(); ++j)
            {
                double delta = points[i].positions[j] - points[i - 1].positions[j];
                distance += delta * delta;
            }
            metrics.joint_length += std::sqrt(distance);
        }

        // Calculate Cartesian path length (based on end-effector position)
        std::vector<geometry_msgs::Pose> waypoints;
        waypoints.reserve(points.size());

        robot_trajectory::RobotTrajectory rt(robot_model, group_name);
        rt.setRobotTrajectoryMsg(*move_group.getCurrentState(), plan.trajectory_);
        size_t waypoint_count = rt.getWayPointCount();

        for (size_t i = 0; i < waypoint_count; ++i)
        {
            const moveit::core::RobotState &state = rt.getWayPoint(i);
            const Eigen::Isometry3d &tf = state.getGlobalLinkTransform("hammer_link"); // EE link
            geometry_msgs::Pose pose;
            pose.position.x = tf.translation().x();
            pose.position.y = tf.translation().y();
            pose.position.z = tf.translation().z();
            Eigen::Quaterniond q(tf.rotation());
            pose.orientation.x = q.x();
            pose.orientation.y = q.y();
            pose.orientation.z = q.z();
            pose.orientation.w = q.w();
            waypoints.push_back(pose);
        }

        for (size_t i = 1; i < waypoints.size(); ++i)
        {
            double dx = waypoints[i].position.x - waypoints[i - 1].position.x;
            double dy = waypoints[i].position.y - waypoints[i - 1].position.y;
            double dz = waypoints[i].position.z - waypoints[i - 1].position.z;
            metrics.cartesian_length += std::sqrt(dx * dx + dy * dy + dz * dz);
        }

        // Calculate smoothness (simple jerk approximation)
        for (size_t i = 2; i < points.size(); ++i)
        {
            for (size_t j = 0; j < points[i].positions.size(); ++j)
            {
                double jerk = points[i].positions[j] - 2 * points[i - 1].positions[j] + points[i - 2].positions[j];
                metrics.smoothness += jerk * jerk;
            }
        }

        // Calculate safety = min obstacle distance
        double min_obstacle_dist = std::numeric_limits<double>::max();
        for (size_t i = 0; i < waypoint_count; ++i)
        {
            const moveit::core::RobotState &state = rt.getWayPoint(i);

            collision_detection::CollisionRequest collision_request;
            collision_request.distance = true;
            collision_detection::CollisionResult collision_result;
            planning_scene->checkCollision(collision_request, collision_result, state);

            if (collision_result.collision)
            {
                min_obstacle_dist = 0.0;
                break;
            }
            else if (collision_result.distance < min_obstacle_dist)
            {
                min_obstacle_dist = collision_result.distance;
            }
        }
        metrics.safety = min_obstacle_dist;

        metrics.plan = plan;
    };

    // Retry planning up to max_retries times
    for (int i = 0; i < max_retries; ++i)
    {
        // Switch planners between attempts
        if (i == max_retries - 1)
        {
            ROS_WARN_STREAM("[" << i << "] Switching to PRM* for the final attempt...");
            move_group.setPlannerId("PRMstarkConfigDefault");
        }
        else
        {
            ROS_INFO_STREAM("[" << i << "] Using RRT planner...");
            move_group.setPlannerId("RRTstarkConfigDefault");
        }

        // Plan
        moveit::planning_interface::MoveGroupInterface::Plan current_plan;

        {
            // Lock the mutex before calling plan (thread safety)
            std::lock_guard<std::mutex> lock(g_move_group_mutex);
            bool success = (move_group.plan(current_plan) == moveit::core::MoveItErrorCode::SUCCESS);
            if (!success)
            {
                ROS_WARN_STREAM("[" << i << "] plan() failed.");
                // Even if plan failed, it's an attempt
                plans_attempted++;
                continue;
            }
        }

        // Increment plans_attempted since a plan was attempted
        plans_attempted++;

        // Check if plan is collision-free
        if (!isAccessible(current_plan))
        {
            ROS_WARN_STREAM("[" << i << "] Plan is not accessible (collision).");
            continue;
        }

        // Compute metrics for the successful plan
        InternalPlanMetrics pm;
        calculateMetrics(current_plan, pm);
        ROS_INFO_STREAM("[" << i << "] Safety=" << pm.safety
                            << " JointLen=" << pm.joint_length
                            << " CartLen=" << pm.cartesian_length
                            << " Smooth=" << pm.smoothness);

        // Store the plan
        successful_plans.push_back(pm);
        plans_successful++;
    }

    if (successful_plans.empty())
    {
        ROS_ERROR_STREAM("No successful plans found after " << max_retries << " attempts.");
        return false;
    }

    // Populate the output vector with all successful plans
    for (const auto &internal_pm : successful_plans)
    {
        PlanMetrics pm_out;
        pm_out.thread_id = -1; // Thread ID will be assigned later
        pm_out.plans_attempted = plans_attempted;
        pm_out.plans_successful = plans_successful;
        pm_out.plan = internal_pm.plan;
        pm_out.safety = internal_pm.safety;
        pm_out.joint_length = internal_pm.joint_length;
        pm_out.cartesian_length = internal_pm.cartesian_length;
        pm_out.smoothness = internal_pm.smoothness;
        pm_out.success = true;
        successful_plans_out.push_back(pm_out);
    }

    return true;
}

/**
 * Thread function for parallel motion planning
 *
 * This function runs in a separate thread and performs the following tasks:
 * 1. Creates a local planning scene
 * 2. Computes accessible approach angles for a given target point
 * 3. Selects an optimal approach angle
 * 4. Plans and evaluates multiple trajectories to the selected approach pose
 *
 * @param thread_id The ID of the thread
 * @param robot_model Pointer to the robot model
 * @param selected_centroid The target centroid point to approach
 * @param selected_normal The normal vector at the target point
 * @param approach_distance The distance to keep from the target point
 */
void runPlanningThread(int thread_id,
                       const moveit::core::RobotModelConstPtr &robot_model,
                       const geometry_msgs::Point &selected_centroid,
                       const geometry_msgs::Vector3 &selected_normal,
                       double approach_distance)
{
    // 1) Create a local planning scene copy for this thread
    planning_scene::PlanningScenePtr local_scene(new planning_scene::PlanningScene(robot_model));
    // The planning scene can be populated with obstacles if needed
    // Example: local_scene->getWorldNonConst()->addToObject(...);

    // 2) Create a MoveGroupInterface for this thread
    moveit::planning_interface::MoveGroupInterface move_group("manipulator");

    // 3) Define local coordinate system based on the surface normal
    tf2::Vector3 normal_vector(selected_normal.x, selected_normal.y, selected_normal.z);
    normal_vector.normalize();
    normal_vector = -normal_vector; // Invert normal to point away from surface

    // Create a local coordinate system with z-axis aligned with the normal
    tf2::Vector3 arbitrary;
    if (std::abs(normal_vector.z()) < 0.99)
    {
        arbitrary = tf2::Vector3(0, 0, 1);
    }
    else
    {
        arbitrary = tf2::Vector3(1, 0, 0);
    }

    tf2::Vector3 x_axis = normal_vector.cross(arbitrary).normalized();
    tf2::Vector3 y_axis = normal_vector.cross(x_axis).normalized();

    // Create rotation matrix from the coordinate system
    tf2::Matrix3x3 rotation_matrix(
        x_axis.getX(), y_axis.getX(), normal_vector.getX(),
        x_axis.getY(), y_axis.getY(), normal_vector.getY(),
        x_axis.getZ(), y_axis.getZ(), normal_vector.getZ());

    // 4) Angle sampling parameters
    double initial_step_deg = 60.0; // Initial coarse step size
    double fine_step_deg = 10;      // Fine step size for detailed search

    double min_angle_deg = 0.0;
    double max_angle_deg = 360.0;

    // Generate coarse angle samples around the normal
    std::vector<double> coarse_angles_deg;
    for (double angle = min_angle_deg; angle < max_angle_deg; angle += initial_step_deg)
    {
        coarse_angles_deg.push_back(angle);
    }

    std::vector<std::pair<double, double>> accessible_angle_ranges;

    // 5) Lambda function to check if a specific angle is accessible
    auto checkAccessibilityAtAngle = [&](double angle_deg) -> bool
    {
        double angle_rad = angle_deg * M_PI / 180.0;

        tf2::Quaternion q_rot;
        q_rot.setRPY(0, 0, angle_rad);
        q_rot.normalize();

        tf2::Matrix3x3 additional_rotation(q_rot);
        tf2::Matrix3x3 new_rotation_matrix = rotation_matrix * additional_rotation;

        double adjusted_offset_y = adjustOffsetY(angle_deg);
        tf2::Vector3 local_target_position(0.0, adjusted_offset_y, approach_distance);
        tf2::Vector3 global_target_position = new_rotation_matrix * local_target_position +
                                              tf2::Vector3(selected_centroid.x, selected_centroid.y, selected_centroid.z);

        tf2::Quaternion q_final;
        new_rotation_matrix.getRotation(q_final);
        q_final.normalize();

        geometry_msgs::Pose target_pose;
        target_pose.position.x = global_target_position.x();
        target_pose.position.y = global_target_position.y();
        target_pose.position.z = global_target_position.z();
        target_pose.orientation = tf2::toMsg(q_final);

        // Perform IK calculation
        moveit::core::RobotStatePtr kinematic_state(new moveit::core::RobotState(robot_model));
        kinematic_state->setToDefaultValues();
        bool found_ik = kinematic_state->setFromIK(move_group.getRobotModel()->getJointModelGroup("manipulator"), target_pose);

        if (found_ik)
        {
            // Check for collisions
            collision_detection::CollisionRequest collision_request;
            collision_detection::CollisionResult collision_result;
            collision_request.group_name = "manipulator";
            collision_request.contacts = true;
            local_scene->checkCollision(collision_request, collision_result, *kinematic_state);

            if (!collision_result.collision)
            {
                return true; // Accessible
            }
        }
        return false; // Not accessible
    };

    // 6) Find accessible angle ranges using coarse sampling
    double range_start = -1.0;
    for (double angle_deg : coarse_angles_deg)
    {
        if (checkAccessibilityAtAngle(angle_deg))
        {
            if (range_start < 0.0)
            {
                range_start = angle_deg;
            }
        }
        else
        {
            if (range_start >= 0.0)
            {
                accessible_angle_ranges.emplace_back(range_start, angle_deg - initial_step_deg);
                range_start = -1.0;
            }
        }
    }
    // Handle last range if it extends to 360 degrees
    if (range_start >= 0.0)
    {
        accessible_angle_ranges.emplace_back(range_start, max_angle_deg);
    }

    // 7) Perform fine sampling within accessible ranges
    std::set<double> accessible_angles_deg;
    for (const auto &range : accessible_angle_ranges)
    {
        for (double angle_deg = range.first; angle_deg <= range.second; angle_deg += fine_step_deg)
        {
            if (checkAccessibilityAtAngle(angle_deg))
            {
                accessible_angles_deg.insert(angle_deg);
            }
        }
    }

    // 8) Compute refined accessible angle ranges
    std::vector<std::pair<double, double>> accessible_angle_ranges_fine;
    if (!accessible_angles_deg.empty())
    {
        std::vector<double> sorted_angles(accessible_angles_deg.begin(), accessible_angles_deg.end());
        std::sort(sorted_angles.begin(), sorted_angles.end());

        double current_start = sorted_angles.front();
        double previous_angle = sorted_angles.front();

        for (size_t i = 1; i < sorted_angles.size(); ++i)
        {
            if (sorted_angles[i] - previous_angle > fine_step_deg * 1.5)
            {
                accessible_angle_ranges_fine.emplace_back(current_start, previous_angle);
                current_start = sorted_angles[i];
            }
            previous_angle = sorted_angles[i];
        }
        accessible_angle_ranges_fine.emplace_back(current_start, previous_angle);

        ROS_INFO_STREAM("Accessible angle ranges (degrees) in Thread " << thread_id << ":");
        for (const auto &range : accessible_angle_ranges_fine)
        {
            ROS_INFO_STREAM("[Thread " << thread_id << "] From " << range.first << " to " << range.second);
        }
    }
    else
    {
        ROS_WARN_STREAM("[Thread " << thread_id << "] No accessible angles found.");
    }

    // 9) Select the optimal angle and adjust offset_y
    double selected_angle_deg = 0.0;
    double adjusted_offset_y = OFFSET_Y_DEFAULT;

    // Use the local planning scene to select optimal angle
    if (selectOptimalAngle(selected_angle_deg, adjusted_offset_y, accessible_angle_ranges_fine,
                           robot_model, local_scene, selected_centroid, rotation_matrix, approach_distance))
    {
        // Valid angle and offset_y found
        ROS_INFO_STREAM("[Thread " << thread_id << "] Successfully selected angle: "
                                   << selected_angle_deg << " degrees with offset_y: " << adjusted_offset_y);
    }
    else
    {
        // Using default values
        ROS_WARN_STREAM("[Thread " << thread_id << "] Failed to select a feasible angle. "
                                   << "Using default angle: " << selected_angle_deg << " degrees with offset_y: "
                                   << adjusted_offset_y);
    }

    // 10) Compute final target pose based on selected angle
    double selected_angle_rad = selected_angle_deg * M_PI / 180.0;
    tf2::Quaternion q_selected_rot;
    q_selected_rot.setRPY(0, 0, selected_angle_rad);
    q_selected_rot.normalize();

    tf2::Matrix3x3 selected_rotation_matrix(q_selected_rot);
    tf2::Matrix3x3 final_rotation_matrix = rotation_matrix * selected_rotation_matrix;

    double offset_x = 0.0; // Can be adjusted if needed

    tf2::Vector3 local_target_position(offset_x, adjusted_offset_y, approach_distance);
    tf2::Vector3 final_target_position = final_rotation_matrix * local_target_position +
                                         tf2::Vector3(selected_centroid.x, selected_centroid.y, selected_centroid.z);

    // Get the final orientation from the rotation matrix
    tf2::Quaternion q_final_selected;
    final_rotation_matrix.getRotation(q_final_selected);
    q_final_selected.normalize();

    // Convert to geometry_msgs types
    geometry_msgs::Point final_position;
    final_position.x = final_target_position.x();
    final_position.y = final_target_position.y();
    final_position.z = final_target_position.z();

    geometry_msgs::Quaternion final_orientation = tf2::toMsg(q_final_selected);

    // Create the final target pose
    geometry_msgs::Pose final_target_pose;
    final_target_pose.position = final_position;
    final_target_pose.orientation = final_orientation;

    // 11) Set the target pose for planning
    move_group.setPoseTarget(final_target_pose);

    // Log pose information
    ROS_INFO_STREAM("[Thread " << thread_id << "] Final Position: x = " << final_position.x
                               << ", y = " << final_position.y
                               << ", z = " << final_position.z);
    ROS_INFO_STREAM("[Thread " << thread_id << "] Final Orientation: x = " << final_orientation.x
                               << ", y = " << final_orientation.y
                               << ", z = " << final_orientation.z
                               << ", w = " << final_orientation.w);

    ROS_INFO_STREAM("[Thread " << thread_id << "] Selected angle: " << selected_angle_deg
                               << " degrees with offset_y: " << adjusted_offset_y);
    ROS_INFO_STREAM("[Thread " << thread_id << "] Planning to the selected target pose...");

    // 12) Generate motion plans and evaluate metrics
    std::vector<PlanMetrics> successful_plans;
    if (plan_safe(move_group, successful_plans, local_scene))
    {
        ROS_INFO_STREAM("[Thread " << thread_id << "] Planning successful. Storing the plans.");
        // Store all successful plans in the global vector with thread_id
        {
            std::lock_guard<std::mutex> lock(g_plan_mutex);
            for (auto &pm : successful_plans)
            {
                pm.thread_id = thread_id; // Assign thread ID
                g_all_thread_plans.push_back(pm);
            }
        }
    }
    else
    {
        ROS_ERROR_STREAM("[Thread " << thread_id << "] Failed to plan to the selected target pose.");
    }

    // Clear the target pose for the next planning
    move_group.clearPoseTargets();
}

/**
 * Check if one plan dominates another in the Pareto sense
 *
 * In Pareto optimization, a solution dominates another if it is better or equal
 * in all metrics, and strictly better in at least one metric.
 *
 * @param a First plan metrics to compare
 * @param b Second plan metrics to compare
 * @return true if plan a dominates plan b, false otherwise
 */
bool dominates(const PlanMetrics &a, const PlanMetrics &b)
{
    // Plan a must be better or equal in all metrics to dominate plan b
    bool better_or_equal =
        (a.safety >= b.safety) &&             // Higher safety is better
        (a.joint_length <= b.joint_length) && // Lower joint length is better
        (a.smoothness <= b.smoothness);       // Lower smoothness (jerk) is better

    // Plan a must be strictly better in at least one metric
    bool strictly_better =
        (a.safety > b.safety) ||
        (a.joint_length < b.joint_length) ||
        (a.smoothness < b.smoothness);

    return better_or_equal && strictly_better;
}

/**
 * Identify the Pareto front from a set of plans
 *
 * The Pareto front contains all non-dominated solutions - these are the
 * optimal trade-offs between different metrics where improving one metric
 * would require worsening another.
 *
 * @param plans Vector of all plans with their metrics
 * @return Vector containing only the plans on the Pareto front
 */
std::vector<PlanMetrics> identifyParetoFront(const std::vector<PlanMetrics> &plans)
{
    std::vector<PlanMetrics> pareto_front;

    // For each plan, check if it's dominated by any other plan
    for (const auto &plan_a : plans)
    {
        bool dominated = false;
        for (const auto &plan_b : plans)
        {
            if (&plan_a == &plan_b)
                continue; // Skip comparing with itself
            if (dominates(plan_b, plan_a))
            {
                dominated = true;
                break;
            }
        }
        // If not dominated by any other plan, add to Pareto front
        if (!dominated)
        {
            pareto_front.push_back(plan_a);
        }
    }

    return pareto_front;
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "normal3");
    ros::NodeHandle n;

    // Add AsyncSpinner to handle ROS callbacks
    ros::AsyncSpinner spinner(4); // 4 threads for handling callbacks
    spinner.start();

    // Measure overall process start time
    auto overall_start = std::chrono::high_resolution_clock::now();

    try
    {
        static const std::string PLANNING_GROUP_ARM = "manipulator";

        // Initialize MoveGroupInterface
        moveit::planning_interface::MoveGroupInterface move_group_interface_arm(PLANNING_GROUP_ARM);

        // Set planner configuration
        move_group_interface_arm.setPlanningTime(20.0);
        move_group_interface_arm.setNumPlanningAttempts(30);

        // Adjust precision
        move_group_interface_arm.setGoalPositionTolerance(0.001);   // 0.1mm
        move_group_interface_arm.setGoalOrientationTolerance(0.01); // ~0.057 degrees

        // Capture initial pose
        ROS_INFO_STREAM("Capturing the initial pose...");
        geometry_msgs::Pose initial_pose = move_group_interface_arm.getCurrentPose().pose;
        geometry_msgs::Quaternion fixed_orientation = initial_pose.orientation;

        // Set up OpenCV service client
        ros::ServiceClient all_normal_client = n.serviceClient<opencv_services::all_normal>("all_normal_service");

        opencv_services::all_normal srv;
        srv.request.header.stamp = ros::Time::now();
        srv.request.header.frame_id = "base_link"; // Adjust as needed

        // Measure service call time
        auto service_start = std::chrono::high_resolution_clock::now();
        if (!callAllNormalService(all_normal_client, srv, 6))
        {
            ROS_ERROR_STREAM("Exiting due to service call failure.");
            throw std::runtime_error("Service call failed.");
        }
        auto service_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> service_duration = service_end - service_start;
        ROS_INFO_STREAM("Service call took " << service_duration.count() << " seconds.");

        for (size_t i = 0; i < srv.response.component_positions.size(); ++i)
        {
            const auto &pt = srv.response.component_positions[i];
            ROS_INFO_STREAM("Centroid " << i << " position: [" << pt.x << ", " << pt.y << ", " << pt.z << "]");
        }

        if (srv.response.component_positions.empty())
        {
            ROS_ERROR_STREAM("No centroids found in the service response.");
            throw std::runtime_error("No centroids found.");
        }

        // ----------------------------------------------------
        // **Prepare work for multi-threaded planning**
        // ----------------------------------------------------
        // Prepare centroids and normal vectors for each thread
        struct CentroidNormal
        {
            geometry_msgs::Point centroid;
            geometry_msgs::Vector3 normal;
        };

        std::vector<CentroidNormal> centroid_normals;
        for (size_t i = 0; i < srv.response.component_positions.size(); ++i)
        {
            if (i >= srv.response.normals.size())
            {
                ROS_WARN_STREAM("Centroid " << i << " has no corresponding normal vector. Skipping.");
                continue;
            }
            CentroidNormal cn;
            cn.centroid = srv.response.component_positions[i];
            cn.normal = srv.response.normals[i];
            centroid_normals.push_back(cn);
        }

        // Select only a specific centroid in the main function
        size_t desired_centroid_index = 1;

        if (desired_centroid_index >= srv.response.component_positions.size())
        {
            ROS_ERROR_STREAM("Desired centroid index " << desired_centroid_index << " is out of range.");
            throw std::runtime_error("Desired centroid index out of range.");
        }

        if (desired_centroid_index >= srv.response.normals.size())
        {
            ROS_ERROR_STREAM("Desired centroid index " << desired_centroid_index << " has no corresponding normal vector.");
            throw std::runtime_error("Desired centroid index has no corresponding normal vector.");
        }

        CentroidNormal selected_cn;
        selected_cn.centroid = srv.response.component_positions[desired_centroid_index];
        selected_cn.normal = srv.response.normals[desired_centroid_index];
        centroid_normals.clear();
        centroid_normals.push_back(selected_cn); // Now centroid_normals contains only the one selected centroid

        // ----------------------------------------------------
        // **Initialize and submit tasks to ThreadPool for multi-threaded planning**
        // ----------------------------------------------------
        constexpr int THREADS_COUNT = 15;

        // Create thread pool (adjusted to hardware concurrency)
        unsigned int num_threads = std::thread::hardware_concurrency();
        if (num_threads == 0)
            num_threads = 20; // Set default value
        ThreadPool pool(num_threads);
        ROS_INFO_STREAM("ThreadPool initialized with " << num_threads << " threads.");

        // Vector for task submission
        std::vector<std::future<void>> futures;

        // Measure planning phase start time
        auto planning_start = std::chrono::high_resolution_clock::now();

        for (size_t i = 0; i < centroid_normals.size(); ++i)
        {
            for (int t = 0; t < THREADS_COUNT; ++t)
            {
                int thread_id = i * THREADS_COUNT + t;
                // Submit task to thread pool
                futures.emplace_back(
                    pool.enqueue(runPlanningThread, thread_id, move_group_interface_arm.getRobotModel(),
                                 centroid_normals[i].centroid, centroid_normals[i].normal, -0.115));
            }
        }

        // Wait for all tasks to complete
        for (auto &fut : futures)
        {
            try
            {
                fut.get();
            }
            catch (const std::exception &e)
            {
                ROS_ERROR_STREAM("Exception in planning thread: " << e.what());
            }
        }

        // Measure planning phase end time
        auto planning_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> planning_duration = planning_end - planning_start;
        ROS_INFO_STREAM("Planning phase took " << planning_duration.count() << " seconds.");

        ROS_INFO_STREAM("All planning threads finished.");

        // ----------------------------------------------------
        // **Output plan information for each thread**
        // ----------------------------------------------------
        // if (g_all_thread_plans.empty()) {
        //     ROS_ERROR_STREAM("No valid plans found from any thread.");
        // } else {
        //     ROS_INFO_STREAM("=== Collected plan information from all threads ===");
        //     std::lock_guard<std::mutex> lock(g_plan_mutex);
        //     for (const auto& pm : g_all_thread_plans) {
        //         ROS_INFO_STREAM("Thread ID: " << pm.thread_id);
        //         ROS_INFO_STREAM("  Plans Attempted: " << pm.plans_attempted);
        //         ROS_INFO_STREAM("  Plans Successful: " << pm.plans_successful);
        //         ROS_INFO_STREAM("  Success: " << (pm.success ? "Yes" : "No"));
        //         if (pm.success) {
        //             ROS_INFO_STREAM("  Safety: " << pm.safety);
        //             ROS_INFO_STREAM("  Joint Length: " << pm.joint_length);
        //             ROS_INFO_STREAM("  Cartesian Length: " << pm.cartesian_length);
        //             ROS_INFO_STREAM("  Smoothness: " << pm.smoothness);
        //             // Add additional plan information output here if needed
        //         }
        //         ROS_INFO_STREAM("-----------------------------------");
        //     }
        // }

        // ----------------------------------------------------
        // **Best plan selection and threshold application** (Modified)
        // ----------------------------------------------------

        // Log number of plans before filtering
        ROS_INFO_STREAM("Number of all plans before filtering: " << g_all_thread_plans.size());

        if (g_all_thread_plans.empty())
        {
            ROS_ERROR_STREAM("No valid plans found from any thread.");
            throw std::runtime_error("No valid plans found.");
        }

        // Define threshold constants
        const double MIN_ACCEPTABLE_OBSTACLE_DISTANCE = 0.0001;
        const double MAX_JOINT_LENGTH = 20.0;
        const double MAX_SMOOTHNESS_THRESHOLD = 0.5;

        // Apply thresholds to the collected plans
        std::vector<PlanMetrics> filtered_plans;
        {
            std::lock_guard<std::mutex> lock(g_plan_mutex);
            for (const auto &pm : g_all_thread_plans)
            {
                if (pm.success &&
                    pm.safety >= MIN_ACCEPTABLE_OBSTACLE_DISTANCE &&
                    pm.joint_length <= MAX_JOINT_LENGTH &&
                    pm.smoothness <= MAX_SMOOTHNESS_THRESHOLD)
                {
                    filtered_plans.push_back(pm);
                }
            }
        }

        // Log number of filtered plans
        ROS_INFO_STREAM("Number of filtered plans: " << filtered_plans.size());

        if (filtered_plans.empty())
        {
            ROS_ERROR_STREAM("No plans met the threshold criteria.");
            throw std::runtime_error("No plans met the threshold criteria.");
        }
        else
        {
            ROS_INFO_STREAM(filtered_plans.size() << " plans met the threshold criteria.");
        }

        // **Identify and select Pareto front**
        std::vector<PlanMetrics> pareto_front = identifyParetoFront(filtered_plans);

        if (pareto_front.empty())
        {
            ROS_ERROR_STREAM("No Pareto optimal plans found.");
            throw std::runtime_error("No Pareto optimal plans found.");
        }

        ROS_INFO_STREAM("=== Pareto Front Plans ===");
        for (const auto &pm : pareto_front)
        {
            ROS_INFO_STREAM("Thread ID: " << pm.thread_id
                                          << ", Safety: " << pm.safety
                                          << ", Joint Length: " << pm.joint_length
                                          << ", Cartesian Length: " << pm.cartesian_length
                                          << ", Smoothness: " << pm.smoothness);
        }

        // **Apply user-defined weights to select the optimal solution within the Pareto front (with normalization)**
        // User-defined weights: higher safety is better, lower joint_length and smoothness are better
        double weight_safety = 0.7;
        double weight_joint_length = 0.2;
        double weight_smoothness = 0.1;

        // Compute min and max for each metric
        double min_safety = std::numeric_limits<double>::max();
        double max_safety = std::numeric_limits<double>::lowest();
        double min_joint_length = std::numeric_limits<double>::max();
        double max_joint_length = std::numeric_limits<double>::lowest();
        double min_smoothness = std::numeric_limits<double>::max();
        double max_smoothness = std::numeric_limits<double>::lowest();

        // First calculate the minimum and maximum values for each metric within the Pareto front
        for (const auto &pm : pareto_front)
        {
            if (pm.safety < min_safety)
                min_safety = pm.safety;
            if (pm.safety > max_safety)
                max_safety = pm.safety;

            if (pm.joint_length < min_joint_length)
                min_joint_length = pm.joint_length;
            if (pm.joint_length > max_joint_length)
                max_joint_length = pm.joint_length;

            if (pm.smoothness < min_smoothness)
                min_smoothness = pm.smoothness;
            if (pm.smoothness > max_smoothness)
                max_smoothness = pm.smoothness;
        }

        // Structure to store plans with their scores
        struct ScoredPlan
        {
            double score;
            PlanMetrics pm;
        };

        std::vector<ScoredPlan> scored_pareto_front;

        // Calculate normalized metrics and assign scores to each plan
        for (const auto &pm : pareto_front)
        {
            // Normalize safety (higher is better)
            double normalized_safety = 1.0;
            if (max_safety > min_safety)
            {
                normalized_safety = (pm.safety - min_safety) / (max_safety - min_safety);
            }

            // Normalize joint length (lower is better)
            double normalized_joint_length = 1.0;
            if (max_joint_length > min_joint_length)
            {
                normalized_joint_length = (max_joint_length - pm.joint_length) / (max_joint_length - min_joint_length);
            }

            // Normalize smoothness (lower is better)
            double normalized_smoothness = 1.0;
            if (max_smoothness > min_smoothness)
            {
                normalized_smoothness = (max_smoothness - pm.smoothness) / (max_smoothness - min_smoothness);
            }

            // Calculate final score by applying weights
            double score = (normalized_safety * weight_safety) + (normalized_joint_length * weight_joint_length) + (normalized_smoothness * weight_smoothness);

            scored_pareto_front.push_back(ScoredPlan{score, pm});
        }

        // Sort in descending order by score (highest score first)
        std::sort(scored_pareto_front.begin(), scored_pareto_front.end(),
                  [](const ScoredPlan &a, const ScoredPlan &b) -> bool
                  {
                      return a.score > b.score;
                  });

        ROS_INFO_STREAM("=== Sorted Pareto Front Plans by Normalized Score ===");
        for (const auto &sp : scored_pareto_front)
        {
            ROS_INFO_STREAM("Thread ID: " << sp.pm.thread_id << ", Score: " << sp.score
                                          << ", Safety: " << sp.pm.safety
                                          << ", Joint Length: " << sp.pm.joint_length
                                          << ", Cartesian Length: " << sp.pm.cartesian_length
                                          << ", Smoothness: " << sp.pm.smoothness);
        }

        // **Try executing plans sequentially starting from the best one**
        bool executed = false;
        moveit::planning_interface::MoveGroupInterface move_group_interface_execute(PLANNING_GROUP_ARM);

        // Start timing for plan selection and execution
        auto selection_start = std::chrono::high_resolution_clock::now();

        for (const auto &sp : scored_pareto_front)
        {
            ROS_INFO_STREAM("Attempting to execute plan from Thread ID: " << sp.pm.thread_id
                                                                          << " with Normalized Score: " << sp.score);

            moveit::core::MoveItErrorCode exec_result = move_group_interface_execute.execute(sp.pm.plan);

            if (exec_result == moveit::core::MoveItErrorCode::SUCCESS)
            {
                ROS_INFO_STREAM("Successfully executed the best plan from Pareto front!");
                executed = true;
                break; // Successfully executed, exit the loop
            }
            else
            {
                ROS_WARN_STREAM("Failed to execute the best plan. Attempting the next best plan.");
            }
        }

        // End timing for plan selection and execution
        auto selection_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> selection_duration = selection_end - selection_start;
        ROS_INFO_STREAM("Plan selection and execution phase took " << selection_duration.count() << " seconds.");

        if (!executed)
        {
            ROS_ERROR_STREAM("All plans failed to execute.");
        }

        // ----------------------------------------------------
        // **Measuring and logging the end time of the entire process**
        // ----------------------------------------------------
        auto overall_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> overall_duration = overall_end - overall_start;
        ROS_INFO_STREAM("Total time until best plan selection: " << overall_duration.count() << " seconds.");

        // ----------------------------------------------------
        // **Save plan information to CSV files (separate files)**
        // ----------------------------------------------------
        std::ofstream all_plans_file("all_plans.csv");
        std::ofstream filtered_plans_file("filtered_plans.csv");
        std::ofstream pareto_front_plans_file("pareto_front_plans.csv");

        if (!all_plans_file.is_open() || !filtered_plans_file.is_open() || !pareto_front_plans_file.is_open())
        {
            ROS_ERROR_STREAM("Failed to open CSV files for writing.");
            throw std::runtime_error("Failed to open CSV files.");
        }

        // Write CSV file headers
        std::string header = "thread_id,plans_attempted,plans_successful,success,safety,joint_length,cartesian_length,smoothness\n";
        all_plans_file << header;
        filtered_plans_file << header;
        pareto_front_plans_file << header;

        // Record all plans to CSV file
        {
            std::lock_guard<std::mutex> lock(g_plan_mutex);
            for (const auto &pm : g_all_thread_plans)
            {
                all_plans_file << pm.thread_id << ","
                               << pm.plans_attempted << ","
                               << pm.plans_successful << ","
                               << (pm.success ? "Yes" : "No") << ","
                               << pm.safety << ","
                               << pm.joint_length << ","
                               << pm.cartesian_length << ","
                               << pm.smoothness << "\n";
            }
        }

        // Record filtered plans to CSV file
        for (const auto &pm : filtered_plans)
        {
            filtered_plans_file << pm.thread_id << ","
                                << pm.plans_attempted << ","
                                << pm.plans_successful << ","
                                << (pm.success ? "Yes" : "No") << ","
                                << pm.safety << ","
                                << pm.joint_length << ","
                                << pm.cartesian_length << ","
                                << pm.smoothness << "\n";
        }

        // Record Pareto front plans to CSV file
        for (const auto &pm : pareto_front)
        {
            pareto_front_plans_file << pm.thread_id << ","
                                    << pm.plans_attempted << ","
                                    << pm.plans_successful << ","
                                    << (pm.success ? "Yes" : "No") << ","
                                    << pm.safety << ","
                                    << pm.joint_length << ","
                                    << pm.cartesian_length << ","
                                    << pm.smoothness << "\n";
        }

        // Close files
        all_plans_file.close();
        filtered_plans_file.close();
        pareto_front_plans_file.close();

        ROS_INFO_STREAM("Plan information has been saved to CSV files.");
    }
    catch (const std::exception &e)
    {
        // Measure and log the end time of the process in case of error
        auto overall_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> overall_duration = overall_end - overall_start;
        ROS_INFO_STREAM("Total time until error occurred: " << overall_duration.count() << " seconds.");
        ROS_ERROR_STREAM("Exception: " << e.what());
        ros::shutdown();
        return 1;
    }

    ros::shutdown();
    return 0;
}